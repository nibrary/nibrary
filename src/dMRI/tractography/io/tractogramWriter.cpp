#include "tractogramWriter.h"
#include "dMRI/tractography/io/tractogramReader.h"
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <ratio>

#ifdef _WIN32
#undef byte
#endif

using namespace NIBR;

bool NIBR::writeTractogram(std::string fname,NIBR::TractogramReader* tractogram) 
{

    std::string ext = getFileExtension(fname);

    if (ext == "tck")
        writeTractogram_TCK(fname,tractogram);
    else if( ext == "trk")
        writeTractogram_TRK(fname,tractogram);
    else if( ext == "vtk")
        writeTractogram_VTK_binary(fname,tractogram);
    else {
        disp(MSG_ERROR,"Cannot write output. Unknown file extension.");
        return false;
    }

    return true;

}

bool NIBR::writeTractogram(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram)
{

    std::string ext = getFileExtension(fname);

    if (ext == "tck")
        writeTractogram_TCK(fname,tractogram);
    else if( ext == "vtk")
        writeTractogram_VTK_binary(fname,tractogram);
    else {
		disp(MSG_ERROR,"Cannot write output. Unknown file extension.");
        return false;
    }

    return true;

}

template<typename T>
bool NIBR::writeTractogram(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram,Image<T>* refImg)
{

    std::string ext = getFileExtension(fname);

    if (ext == "tck")
        writeTractogram_TCK(fname,tractogram);
    else if( ext == "trk")
        writeTractogram_TRK(fname,tractogram,refImg);
    else if( ext == "vtk")
        writeTractogram_VTK_binary(fname,tractogram);
    else {
		disp(MSG_ERROR,"Cannot write output. Unknown file extension.");
        return false;
    }

    return true;

}

bool NIBR::writeTractogram_VTK_binary(std::string fname,NIBR::TractogramReader* tractogram) {

    std::vector<std::size_t> idx;
    idx.reserve(tractogram->numberOfStreamlines);
    for (std::size_t n = 0; n < tractogram->numberOfStreamlines; n++) {
        idx.push_back(n);
    }
    return NIBR::writeTractogram_VTK_binary(fname,tractogram,idx);
    
}

bool NIBR::writeTractogram_VTK_binary(std::string out_fname,NIBR::TractogramReader* tractogram,std::vector<std::size_t>& idx) {

    // Prepare output
    FILE *out;
	out = fopen(out_fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    const std::size_t BUFFER_STREAMLINES = 5000; // Will write this many streamlines at a time

    // Prep tractogram
    std::size_t streamlineCount = idx.size();
    std::size_t totalPointCount = 0;

    std::vector<int> len;
    len.reserve(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++) {
        len.push_back(tractogram->len[idx[i]]);
        totalPointCount += len[i];
    }

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "BINARY\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);


    // Buffer for points data
    std::vector<float> pointsBuffer;
    pointsBuffer.reserve(BUFFER_STREAMLINES * 1000 * 3); // Assuming average 1000 points per streamline

    std::size_t currentStreamline = 0;

    while (currentStreamline < streamlineCount) {

        std::size_t batchSize = std::min(BUFFER_STREAMLINES, streamlineCount - currentStreamline);
        
        pointsBuffer.clear();

        // Accumulate points for the current batch
        for (std::size_t i = 0; i < batchSize; ++i) {

            std::size_t idxStream   = currentStreamline + i;

            float** streamline = tractogram->readStreamline(idx[idxStream]);

            if (streamline == nullptr) {
                disp(MSG_ERROR, "Error reading streamline %d from %s", idx[idxStream], tractogram->fileName.c_str());
                fclose(out);
                return false;
            }

            for (int p = 0; p < len[idxStream]; p++) {
                pointsBuffer.push_back(streamline[p][0]);
                pointsBuffer.push_back(streamline[p][1]);
                pointsBuffer.push_back(streamline[p][2]);
                delete[] streamline[p];
            }
            delete[] streamline;
        }

        // Swap byte order for all floats in the buffer
        for (auto& val : pointsBuffer) {
            swapByteOrder(val);
        }

        // Write the binary data in one fwrite call
        std::size_t bytesToWrite = pointsBuffer.size() * sizeof(float);
        std::size_t written      = fwrite(pointsBuffer.data(), 1, bytesToWrite, out);

        if (written != bytesToWrite) {
            disp(MSG_ERROR, "Error writing points data to file.");
            fclose(out);
            return false;
        }

        currentStreamline += batchSize;
    }

    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Buffer for lines data
    std::vector<int> linesBuffer;
    linesBuffer.reserve(BUFFER_STREAMLINES * 1000); // Assuming average 1000 points per streamline

    // Current index tracking
    currentStreamline   = 0;
    int continue_index  = 0;

    while (currentStreamline < streamlineCount) {

        std::size_t batchSize = std::min(BUFFER_STREAMLINES, streamlineCount - currentStreamline);

        linesBuffer.clear();

        // Accumulate lines for the current batch
        for (std::size_t i = 0; i < batchSize; ++i) {
            int length = len[currentStreamline + i];
            linesBuffer.push_back(length);
            for (int p = 0; p < length; ++p) {
                linesBuffer.push_back(continue_index + p);
            }
            continue_index += length;
        }

        // Swap byte order for all ints in the buffer
        for (auto& val : linesBuffer) {
            swapByteOrder(val);
        }

        // Write the binary data in one fwrite call
        std::size_t bytesToWrite = linesBuffer.size() * sizeof(int);
        std::size_t written      = fwrite(linesBuffer.data(), 1, bytesToWrite, out);

        if (written != bytesToWrite) {
            disp(MSG_ERROR, "Error writing lines data to file.");
            fclose(out);
            return false;
        }

        currentStreamline += batchSize;
    }

    fclose(out);

    return true;

}

bool NIBR::writeTractogram_VTK_binary(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}


    // Prep tractogram
    std::size_t streamlineCount = tractogram.size();
    std::size_t totalPointCount = 0;

    std::vector<int> len;
    len.resize(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++) {
        len[i]           = tractogram[i].size();
        totalPointCount += len[i];
    }

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());  fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "BINARY\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);
	for (std::size_t i=0; i<streamlineCount; i++) {
        for (int p=0; p<len[i]; p++) {
            float tmp;
            tmp = tractogram[i][p][0]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
            tmp = tractogram[i][p][1]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
            tmp = tractogram[i][p][2]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
        }
    }


    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

	int continue_index = 0;
	for (std::size_t i=0; i<streamlineCount; i++) {

		int first_count = len[i];
		swapByteOrder(first_count); fwrite(&first_count, sizeof(int), 1, out);

		int first_index	= continue_index;
		int last_index	= first_index + len[i];
		for (int i=continue_index; i<last_index; i++) {
			int tmp = i;
			swapByteOrder(tmp); fwrite(&tmp, sizeof(int), 1, out);
		}

		continue_index = last_index;
	}

    fclose (out);
    return true;
}

bool NIBR::writeTractogram_VTK_ascii(std::string fname,NIBR::TractogramReader* tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    // Prep tractogram
    std::size_t streamlineCount = tractogram->numberOfStreamlines;
    std::size_t totalPointCount = tractogram->numberOfPoints;

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "ASCII\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(i);
        for (uint32_t p=0; p<tractogram->len[i]; p++) {
            sprintf(buffer, "%f %f %f\n", streamline[p][0], streamline[p][1], streamline[p][2]);
            fwrite(buffer, sizeof(char), strlen(buffer), out);
            delete[] streamline[p];
        }
        delete[] streamline;
    }

    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

	int continue_index = 0;
	for (std::size_t i=0; i<streamlineCount; i++) {

		int first_count = tractogram->len[i];
        sprintf(buffer, "%d ", first_count); fwrite(buffer, sizeof(char), strlen(buffer), out);

		int first_index	= continue_index;
		int last_index	= first_index + tractogram->len[i];
		
        for (int i=continue_index; i<last_index; i++) {
            sprintf(buffer, "%d ", i); fwrite(buffer, sizeof(char), strlen(buffer), out);
        }

        sprintf(buffer, "\n"); fwrite(buffer, sizeof(char), strlen(buffer), out);

		continue_index = last_index;
	}

    fclose (out);
    return true;

}

bool NIBR::writeTractogram_VTK_ascii(std::string fname,NIBR::TractogramReader* tractogram,std::vector<std::size_t>& idx) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    // Prep tractogram
    std::size_t streamlineCount = idx.size();
    std::size_t totalPointCount = 0;

    std::vector<int> len;
    len.reserve(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++) {
        len.push_back(tractogram->len[idx[i]]);
        totalPointCount += len[i];
    }

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "ASCII\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(idx[i]);
        for (int p=0; p<len[i]; p++) {
            sprintf(buffer, "%f %f %f\n", streamline[p][0], streamline[p][1], streamline[p][2]);
            fwrite(buffer, sizeof(char), strlen(buffer), out);
            delete[] streamline[p];
        }
        delete[] streamline;
    }

    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

	int continue_index = 0;
	for (std::size_t i=0; i<streamlineCount; i++) {

		int first_count = len[i];
        sprintf(buffer, "%d ", first_count); fwrite(buffer, sizeof(char), strlen(buffer), out);

		int first_index	= continue_index;
		int last_index	= first_index + len[i];
		
        for (int i=continue_index; i<last_index; i++) {
            sprintf(buffer, "%d ", i); fwrite(buffer, sizeof(char), strlen(buffer), out);
        }

        sprintf(buffer, "\n"); fwrite(buffer, sizeof(char), strlen(buffer), out);

		continue_index = last_index;
	}

    fclose (out);
    return true;

}


bool NIBR::writeTractogram_VTK_ascii(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}


    // Prep tractogram
    std::size_t streamlineCount = tractogram.size();
    std::size_t totalPointCount = 0;

    std::vector<int> len;
    len.resize(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++) {
        len[i]           = tractogram[i].size();
        totalPointCount += len[i];
    }

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "ASCII\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);
	for (std::size_t i=0; i<streamlineCount; i++) {
        for (int p=0; p<len[i]; p++) {
            sprintf(buffer, "%f %f %f\n", tractogram[i][p][0], tractogram[i][p][1], tractogram[i][p][2]);
            fwrite(buffer, sizeof(char), strlen(buffer), out);
        }
    }

    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

	int continue_index = 0;
	for (std::size_t i=0; i<streamlineCount; i++) {

		int first_count = len[i];
        sprintf(buffer, "%d ", first_count); fwrite(buffer, sizeof(char), strlen(buffer), out);

		int first_index	= continue_index;
		int last_index	= first_index + len[i];
		
        for (int i=continue_index; i<last_index; i++) {
            sprintf(buffer, "%d ", i); fwrite(buffer, sizeof(char), strlen(buffer), out);
        }

        sprintf(buffer, "\n"); fwrite(buffer, sizeof(char), strlen(buffer), out);

		continue_index = last_index;
	}

    fclose (out);
    return true;
}

bool NIBR::writeTractogram_TRK(std::string fname,NIBR::TractogramReader* tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    // Prep tractogram
    std::size_t streamlineCount = tractogram->numberOfStreamlines;

    // Write header
    trkFileStruct trkHeader;
    memset(&trkHeader,0,sizeof(trkFileStruct));
    strcpy(trkHeader.id_string, "TRACK");

    for(int i=0;i<3;++i) {
        trkHeader.dim[i]        = tractogram->imgDims[i];
        trkHeader.voxel_size[i] = tractogram->pixDims[i];
    }
    std::strcpy(trkHeader.voxel_order,tractogram->voxOrdr);

    trkHeader.version = 2;
    for(int i=0;i<4;++i)
		for(int j=0;j<4;++j)
			trkHeader.vox_to_ras[i][j] = tractogram->ijk2xyz[i][j];

    trkHeader.n_count   = streamlineCount;
    trkHeader.hdr_size  = sizeof(trkFileStruct); // This should be 1000
    std::fwrite(&trkHeader, sizeof(trkFileStruct), 1, out);

    // Write points
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(i);
        float tmp[3];
        int len = tractogram->len[i];
        fwrite(&len, sizeof(int), 1, out);
        for (int p=0; p<len; p++) {
            applyTransform(tmp,streamline[p],tractogram->xyz2ijk);
            tmp[0] += 0.5f;
            tmp[1] += 0.5f;
            tmp[2] += 0.5f;
            fwrite(tmp, sizeof(float), 3, out);
            delete[] streamline[p];
        }
        delete[] streamline;
    }

    fclose (out);

    return true;
}

bool NIBR::writeTractogram_TRK(std::string fname,NIBR::TractogramReader* tractogram,std::vector<std::size_t>& idx) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    // Prep tractogram
    std::size_t streamlineCount = idx.size();

    // Write header
    trkFileStruct trkHeader;
    memset(&trkHeader,0,sizeof(trkFileStruct));
    strcpy(trkHeader.id_string, "TRACK");

    for(int i=0;i<3;++i) {
        trkHeader.dim[i]        = tractogram->imgDims[i];
        trkHeader.voxel_size[i] = tractogram->pixDims[i];
    }
    std::strcpy(trkHeader.voxel_order,tractogram->voxOrdr);

    trkHeader.version = 2;
    for(int i=0;i<4;++i)
		for(int j=0;j<4;++j)
			trkHeader.vox_to_ras[i][j] = tractogram->ijk2xyz[i][j];
    
    trkHeader.n_count   = streamlineCount;
    trkHeader.hdr_size  = sizeof(trkFileStruct);
    std::fwrite(&trkHeader, sizeof(trkFileStruct), 1, out);

    // Write points
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(idx[i]);
        float tmp[3];
        int len = tractogram->len[idx[i]];
        fwrite(&len, sizeof(int), 1, out);
        for (int p=0; p<len; p++) {
            applyTransform(tmp,streamline[p],tractogram->xyz2ijk);
            tmp[0] += 0.5f;
            tmp[1] += 0.5f;
            tmp[2] += 0.5f;
            fwrite(tmp, sizeof(float), 3, out);
            delete[] streamline[p];
        }
        delete[] streamline;
    }

    fclose (out);

    return true;
}

template<typename T>
bool NIBR::writeTractogram_TRK(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram, Image<T>* refImg) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}

    // Prep tractogram
    std::size_t streamlineCount = tractogram.size();

    std::vector<int> len;
    len.resize(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++)
        len[i] = tractogram[i].size();


    // Write header
    trkFileStruct trkHeader;
    memset(&trkHeader,0,sizeof(trkFileStruct));
    strcpy(trkHeader.id_string, "TRACK");

    for(int i=0;i<3;++i) {
        trkHeader.dim[i]        = refImg->imgDims[i];
        trkHeader.voxel_size[i] = refImg->pixDims[i];
    }
    std::strcpy(trkHeader.voxel_order,"LAS");

    trkHeader.version = 2;
    float xyz2ijk[4][4];
    for(int i=0;i<4;++i)
		for(int j=0;j<4;++j) {
			trkHeader.vox_to_ras[i][j]  = refImg->ijk2xyz[i][j];
            xyz2ijk[i][j]               = refImg->xyz2ijk[i][j];
        }

    trkHeader.n_count   = streamlineCount;
    trkHeader.hdr_size  = sizeof(trkFileStruct);
    std::fwrite(&trkHeader, sizeof(trkFileStruct), 1, out);

    // Write points
	for (std::size_t i=0; i<streamlineCount; i++) {
        float tmp[3];
        fwrite(&len[i], sizeof(int), 1, out);
        for (int p=0; p<len[i]; p++) {
            applyTransform(tmp,tractogram[i][p],xyz2ijk);
            tmp[0] += 0.5f;
            tmp[1] += 0.5f;
            tmp[2] += 0.5f;
            fwrite(tmp, sizeof(float), 3, out);
        }
    }

    fclose (out);

    return true;
}

bool NIBR::writeTractogram_TCK(std::string fname,NIBR::TractogramReader* tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"w+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}
    
    std::size_t streamlineCount = tractogram->numberOfStreamlines;

    // Write header
    char buffer[256];
    std::string str;
    sprintf(buffer, "mrtrix tracks    \n");           str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "datatype: Float32LE\n");         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "count: %ld\n", streamlineCount); str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "file: . %ld\n", ftell(out)+15);  str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "END\n");                         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    
	//write points
    float NANarr[3] = {NAN,NAN,NAN};
    float INFarr[3] = {INFINITY,INFINITY,INFINITY};
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(i);
        for (std::size_t p=0; p<tractogram->len[i]; p++) {
            fwrite(streamline[p], sizeof(float), 3, out);
            delete[] streamline[p];
        }
        delete[] streamline;
        fwrite(NANarr, sizeof(float), 3, out);
    }
    fwrite(INFarr, sizeof(float), 3, out);
    fclose (out);
    return true;
}

bool NIBR::writeTractogram_TCK(std::string fname,NIBR::TractogramReader* tractogram,std::vector<std::size_t>& idx) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"w+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}
    
    std::size_t streamlineCount = idx.size();

    // Write header
    char buffer[256];
    std::string str;
    sprintf(buffer, "mrtrix tracks    \n");           str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "datatype: Float32LE\n");         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "count: %ld\n", streamlineCount); str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "file: . %ld\n", ftell(out)+15);  str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "END\n");                         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    
	//write points
    float NANarr[3] = {NAN,NAN,NAN};
    float INFarr[3] = {INFINITY,INFINITY,INFINITY};
	for (std::size_t i=0; i<streamlineCount; i++) {
        float** streamline = tractogram->readStreamline(idx[i]);
        for (std::size_t p=0; p<tractogram->len[idx[i]]; p++) {
            fwrite(streamline[p], sizeof(float), 3, out);
            delete[] streamline[p];
        }
        delete[] streamline;
        fwrite(NANarr, sizeof(float), 3, out);
    }
    fwrite(INFarr, sizeof(float), 3, out);
    fclose (out);
    return true;
}

bool NIBR::writeTractogram_TCK(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"w+");
	if (out==NULL) {
		disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}
    
    std::size_t streamlineCount = tractogram.size();

    // Write header
    char buffer[256];
    std::string str;
    sprintf(buffer, "mrtrix tracks    \n");           str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "datatype: Float32LE\n");         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "count: %ld\n", streamlineCount); str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "file: . %ld\n", ftell(out)+15);  str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    sprintf(buffer, "END\n");                         str.assign(buffer); fwrite(str.data(), sizeof(char), str.size(), out);
    
	//write points
    float NANarr[3] = {NAN,NAN,NAN};
    float INFarr[3] = {INFINITY,INFINITY,INFINITY};
	for (std::size_t i=0; i<streamlineCount; i++) {
        for (std::size_t p=0; p<tractogram[i].size(); p++) {
            fwrite(&tractogram[i][p][0], sizeof(float), 1, out);
            fwrite(&tractogram[i][p][1], sizeof(float), 1, out);
            fwrite(&tractogram[i][p][2], sizeof(float), 1, out);
        }
        fwrite(NANarr, sizeof(float), 3, out);
    }
    fwrite(INFarr, sizeof(float), 3, out);
    fclose (out);
    return true;
}


bool NIBR::writeTractogram(std::string fname,NIBR::TractogramReader* tractogram,std::vector<std::size_t>& idx) 
{

    std::string ext = getFileExtension(fname);

    if (ext == "tck")
        writeTractogram_TCK(fname,tractogram,idx);
    else if( ext == "trk")
        writeTractogram_TRK(fname,tractogram,idx);
    else if( ext == "vtk")
        writeTractogram_VTK_binary(fname,tractogram,idx);
    else {
		disp(MSG_ERROR,"Cannot write output. Unknown file extension.");
        return false;
    }

    return true;

}


bool NIBR::writeTractogram(std::string out_fname,std::string inp_fname,std::vector<std::size_t>& idx) {
    NIBR::TractogramReader tractogram(inp_fname);
    return writeTractogram(out_fname,&tractogram,idx);
}


bool NIBR::writeTractogram(std::string out_kept_fname,std::string out_rmvd_fname,std::string inp_fname,std::vector<std::size_t>& idx) {

    // Prep input

    NIBR::TractogramReader tractogram(inp_fname);
    NIBR::writeTractogram(out_kept_fname,&tractogram,idx);


    // Rmvd tractogram
    std::vector<std::size_t> rmvd_idx;
    for (std::size_t i=0; i<tractogram.numberOfStreamlines; i++)
        rmvd_idx.push_back(i);

    removeIdx(rmvd_idx,idx);

    writeTractogram(out_rmvd_fname,&tractogram,rmvd_idx);

    return true;
}


bool NIBR::writeTractogram(std::string fname,std::vector<std::vector<std::vector<float>>>& tractogram,std::vector<NIBR::TractogramField>& fields) {

    // Prepare output
    FILE *out;
	out = fopen(fname.c_str(),"wb+");
	if (out==NULL) {
        disp(MSG_ERROR,"Cannot write output. Output path doesn't exist.");
		return false;
	}


    // Prep tractogram
    std::size_t streamlineCount = tractogram.size();
    std::size_t totalPointCount = 0;

    std::vector<int> len;
    len.resize(streamlineCount);

    for (std::size_t i=0; i<streamlineCount; i++) {
        len[i]           = tractogram[i].size();
        totalPointCount += len[i];
    }

    // Write header
	char buffer[256];
	sprintf(buffer, "# vtk DataFile Version 3.0\n");	    fwrite(buffer, sizeof(char), strlen(buffer), out);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "BINARY\n"); 						    fwrite(buffer, sizeof(char), strlen(buffer), out);
	sprintf(buffer, "DATASET POLYDATA\n"); 				    fwrite(buffer, sizeof(char), strlen(buffer), out);

    // Write points
    sprintf(buffer, "POINTS %lu float\n", totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);
	for (std::size_t i=0; i<streamlineCount; i++) {
        for (int p=0; p<len[i]; p++) {
            float tmp;
            tmp = tractogram[i][p][0]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
            tmp = tractogram[i][p][1]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
            tmp = tractogram[i][p][2]; 	swapByteOrder(tmp); fwrite(&tmp, sizeof(float), 1, out);
        }
    }

    // Write lines
    sprintf(buffer, "LINES %lu %lu\n",streamlineCount,streamlineCount+totalPointCount);
	fwrite(buffer, sizeof(char), strlen(buffer), out);

	int continue_index = 0;
	for (std::size_t i=0; i<streamlineCount; i++) {

		int first_count = len[i];
		swapByteOrder(first_count); fwrite(&first_count, sizeof(int), 1, out);

		int first_index	= continue_index;
		int last_index	= first_index + len[i];
		for (int i=continue_index; i<last_index; i++) {
			int tmp = i;
			swapByteOrder(tmp); fwrite(&tmp, sizeof(int), 1, out);
		}

		continue_index = last_index;
	}

    
    
    // Write fields
    std::vector<int> cellDataInd;
    std::vector<int> pointDataInd;

    for (std::size_t i=0; i<fields.size(); i++) {
        if (fields[i].owner == STREAMLINE_OWNER) cellDataInd.push_back(i);
        if (fields[i].owner == POINT_OWNER)      pointDataInd.push_back(i);
    }

    
    // Write STREAMLINE_OWNER fields
    if (cellDataInd.size()>0) {
        sprintf(buffer,"CELL_DATA %lu\n",streamlineCount); 	fwrite(buffer, sizeof(char), strlen(buffer), out);

        for (std::size_t i=0; i<cellDataInd.size(); i++) {

            sprintf(buffer,"SCALARS %s ",fields[cellDataInd[i]].name.c_str());
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            if (fields[cellDataInd[i]].datatype == FLOAT32_DT) sprintf(buffer,"float ");
            if (fields[cellDataInd[i]].datatype == INT32_DT)   sprintf(buffer,"int ");
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            sprintf(buffer,"%d\n",fields[cellDataInd[i]].dimension);
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            sprintf(buffer,"LOOKUP_TABLE default\n");
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            int**   idata = NULL;
            float** fdata = NULL;
            if (fields[cellDataInd[i]].datatype==INT32_DT)   idata = reinterpret_cast<int**>(fields[cellDataInd[i]].data);
            if (fields[cellDataInd[i]].datatype==FLOAT32_DT) fdata = reinterpret_cast<float**>(fields[cellDataInd[i]].data);

            for (std::size_t s=0; s<streamlineCount; s++) {
                for (int d=0; d<fields[cellDataInd[i]].dimension; d++) {

                    if (fields[cellDataInd[i]].datatype==INT32_DT) {
                        int   tmp = idata[s][d];
                        swapByteOrder(tmp);
                        fwrite(&tmp, sizeof(int), 1, out);
                    }
                    if (fields[cellDataInd[i]].datatype==FLOAT32_DT) {
                        float   tmp = fdata[s][d];
                        swapByteOrder(tmp);
                        fwrite(&tmp, sizeof(float), 1, out);
                    }

                }
            }

        }

    }

    // Write POINT fields
    if (pointDataInd.size()>0) {

        sprintf(buffer,"POINT_DATA %lu\n",totalPointCount); 	
        fwrite(buffer, sizeof(char), strlen(buffer), out);

        for (std::size_t i=0; i<pointDataInd.size(); i++) {

            sprintf(buffer,"SCALARS %s ",fields[pointDataInd[i]].name.c_str());
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            if (fields[pointDataInd[i]].datatype == FLOAT32_DT) sprintf(buffer,"float ");
            if (fields[pointDataInd[i]].datatype == INT32_DT)   sprintf(buffer,"int ");
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            sprintf(buffer,"%d\n",fields[pointDataInd[i]].dimension);
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            sprintf(buffer,"LOOKUP_TABLE default\n");
            fwrite(buffer, sizeof(char), strlen(buffer), out);

            int***   idata = NULL;
            float*** fdata = NULL;
            if (fields[pointDataInd[i]].datatype==INT32_DT)   idata = reinterpret_cast<int***>(fields[pointDataInd[i]].data);
            if (fields[pointDataInd[i]].datatype==FLOAT32_DT) fdata = reinterpret_cast<float***>(fields[pointDataInd[i]].data);

            for (std::size_t s=0; s<streamlineCount; s++) {
                for (int l=0; l<len[s]; l++) {
                    for (int d=0; d<fields[pointDataInd[i]].dimension; d++) {

                        if (fields[pointDataInd[i]].datatype==INT32_DT) {
                            int tmp = idata[s][l][d];
                            swapByteOrder(tmp);
                            fwrite(&tmp, sizeof(int), 1, out);
                        }

                        if (fields[pointDataInd[i]].datatype==FLOAT32_DT) {
                            float tmp = fdata[s][l][d];
                            swapByteOrder(tmp);
                            fwrite(&tmp, sizeof(float), 1, out);

                        }

                    }
                }
            }

        }

    }



    fclose (out);
    return true;
}
