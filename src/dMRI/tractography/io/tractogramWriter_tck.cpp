#include <cmath>       // For NAN, INFINITY
#include <cstring>     // For std::strlen
#include <vector>
#include "base/nibr.h" // For disp, SGNTR
#include "tractogramWriter_tck.h"


namespace NIBR {

TCKWriter::TCKWriter(std::string _filename) : filename_(std::move(_filename)) 
{
    needsByteSwap_ = !is_little_endian(); 
    if (needsByteSwap_) {
        disp(MSG_DEBUG, "TCKWriter: System is big-endian. Byte swapping will be applied for Float32LE output.");
    }
}

TCKWriter::~TCKWriter() 
{
    if (file_ != nullptr) {
        disp(MSG_WARN, "TCKWriter for %s destroyed without explicit close. Attempting to close.", filename_.c_str());
        long dummy1, dummy2;
        close(dummy1, dummy2);
    }
}

bool TCKWriter::open() 
{

    file_ = fopen(filename_.c_str(), "wb+");

    if (file_ == nullptr) {
        disp(MSG_ERROR, "TCKWriter: Cannot open output file: %s", filename_.c_str());
        return false;
    }

    char buffer[256];
    
    fprintf(file_, "mrtrix tracks\n");
    fprintf(file_, "Generated by %s\n", SGNTR().c_str());
    fprintf(file_, "datatype: Float32LE\n");

    posCount_ = ftell(file_);
    fprintf(file_, "count: %-20s\n", "PLACEHOLDER"); // Using a padded string placeholder for safety
    
    posFileOffset_ = ftell(file_);
    fprintf(file_, "file: . %-20s\n", "PLACEHOLDER"); 

    fprintf(file_, "END\n");

    dataStartOffset_ = ftell(file_);

    // Immediately update the file offset placeholder with the correct data offset.
    fseek(file_, posFileOffset_, SEEK_SET);
    sprintf(buffer, "file: . %-20ld", dataStartOffset_); // Use sprintf to format string with padding
    fprintf(file_, "%s\n", buffer); // Then write the string

    // Seek to where binary data writing should begin
    fseek(file_, dataStartOffset_, SEEK_SET);

    currentStreamlineCount_ = 0;
    currentPointCount_ = 0;
    return true;
}

bool TCKWriter::writeBatch(const StreamlineBatch& batch) 
{

    if (file_ == nullptr) {
        disp(MSG_ERROR, "TCKWriter: File not open for writing.");
        return false;
    }

    float NAN_arr[3] = {NAN, NAN, NAN};
    if (needsByteSwap_) {
        for(float& val : NAN_arr) swapByteOrder(val);
    }

    for (const auto& streamline : batch) {
        if (streamline.empty()) {
            continue; 
        }

        // Buffer all points of a streamline to perform byte-swapping efficiently if needed.
        std::vector<float> pointsBuffer;
        pointsBuffer.reserve(streamline.size() * 3);
        for (const auto& point : streamline) {
            pointsBuffer.push_back(point[0]);
            pointsBuffer.push_back(point[1]);
            pointsBuffer.push_back(point[2]);
        }
        
        if (needsByteSwap_) {
            for(float& val : pointsBuffer) swapByteOrder(val);
        }

        // Write points for the streamline
        if (fwrite(pointsBuffer.data(), sizeof(float), pointsBuffer.size(), file_) != pointsBuffer.size()) {
            disp(MSG_ERROR, "TCKWriter: Error writing point data to %s.", filename_.c_str());
            return false;
        }
        currentPointCount_ += streamline.size();

        // Write NAN separator after each streamline's points
        if (fwrite(NAN_arr, sizeof(float), 3, file_) != 3) {
            disp(MSG_ERROR, "TCKWriter: Error writing NAN separator to %s.", filename_.c_str());
            return false;
        }
        currentStreamlineCount_++;
    }

    return true;
}

bool TCKWriter::close(long& finalStreamlineCount, long& finalPointCount) 
{
    if (file_ == nullptr) {
        finalStreamlineCount = currentStreamlineCount_;
        finalPointCount      = currentPointCount_;
        return true; 
    }

    // Write the final end-of-file marker
    float INF_arr[3] = {INFINITY, INFINITY, INFINITY};

    if (needsByteSwap_) {
        for(float& val : INF_arr) swapByteOrder(val);
    }
    fwrite(INF_arr, sizeof(float), 3, file_);

    fflush(file_);

    // Seek back to header positions and write final count value
    char buffer[256];
    fseek(file_, posCount_, SEEK_SET);
    sprintf(buffer, "count: %-20lu", (unsigned long)currentStreamlineCount_);
    fprintf(file_, "%s\n", buffer);
    
    // Close the file
    if (fclose(file_) != 0) {
        disp(MSG_ERROR, "TCKWriter: Error closing file %s.", filename_.c_str());
        file_ = nullptr;
        finalStreamlineCount = currentStreamlineCount_;
        finalPointCount      = currentPointCount_;
        return false;
    }
    
    file_ = nullptr; // Mark as closed
    finalStreamlineCount = currentStreamlineCount_;
    finalPointCount      = currentPointCount_;
    disp(MSG_DEBUG, "TCKWriter: Successfully closed %s. Streamlines: %ld, Points: %ld", filename_.c_str(), finalStreamlineCount, finalPointCount);
    return true;
}

}
