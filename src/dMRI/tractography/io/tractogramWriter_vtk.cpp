#include <iostream>
#include <fstream>
#include <stdio.h>
#include <cstring>
#include <algorithm>

#include "base/verbose.h"
#include "base/dataTypeHandler.h"
#include "base/byteSwapper.h"
#include "tractogramWriter_vtk.h"

using namespace NIBR;

VTKBinaryWriter::VTKBinaryWriter(std::string _filename) : filename(_filename) {}

VTKBinaryWriter::~VTKBinaryWriter() {
    if (file != nullptr) {
        fclose(file); // Ensure file is closed if not done properly
    }
}

void VTKBinaryWriter::writeHeaderPlaceholders() {
    char buffer[256];
    sprintf(buffer, "# vtk DataFile Version 3.0\n");        fwrite(buffer, sizeof(char), strlen(buffer), file);
    sprintf(buffer, "Generated by %s\n", SGNTR().c_str());  fwrite(buffer, sizeof(char), strlen(buffer), file);
    sprintf(buffer, "BINARY\n");                            fwrite(buffer, sizeof(char), strlen(buffer), file);
    sprintf(buffer, "DATASET POLYDATA\n");                  fwrite(buffer, sizeof(char), strlen(buffer), file);

    // Write placeholder for POINTS, use padding for safe overwriting
    sprintf(buffer, "POINTS %20lu float\n", (unsigned long)0); // Padded placeholder
    posPointsHeader = ftell(file);
    fwrite(buffer, sizeof(char), strlen(buffer), file);
}

bool VTKBinaryWriter::open() {
    file = fopen(filename.c_str(), "wb+");
    if (file == NULL) {
        disp(MSG_ERROR, "Cannot open output file: %s", filename.c_str());
        return false;
    }
    writeHeaderPlaceholders();
    return true;
}

bool VTKBinaryWriter::writeBatch(const std::vector<std::vector<std::vector<float>>>& batch) {
    if (file == NULL) return false;

    // Buffer to hold points for one batch write
    std::vector<float> pointsBuffer;
    
    // Estimate a reasonable size, e.g., 5000 streamlines * 100 points * 3 floats
    pointsBuffer.reserve(batch.size() * 100 * 3); 

    for (const auto& streamline : batch) {
        int len = streamline.size();
        if (len > 0) {
            lengths.push_back(len);
            totalPointCount += len;
            totalStreamlineCount++;
            for (const auto& point : streamline) {
                pointsBuffer.push_back(point[0]);
                pointsBuffer.push_back(point[1]);
                pointsBuffer.push_back(point[2]);
            }
        }
    }

    // Swap byte order for all floats in the buffer
    for (auto& val : pointsBuffer) {
        swapByteOrder(val);
    }

    // Write the binary data
    size_t written = fwrite(pointsBuffer.data(), sizeof(float), pointsBuffer.size(), file);

    if (written != pointsBuffer.size()) {
        disp(MSG_ERROR, "Error writing points data to file.");
        return false;
    }

    return true;
}

void VTKBinaryWriter::writeLinesData() {
    std::vector<int> linesBuffer;
    size_t linesDataSize = totalStreamlineCount + totalPointCount;
    linesBuffer.reserve(linesDataSize);

    int currentIndex = 0;
    for (int len : lengths) {
        linesBuffer.push_back(len);
        for (int p = 0; p < len; ++p) {
            linesBuffer.push_back(currentIndex + p);
        }
        currentIndex += len;
    }

    // Swap byte order
    for (auto& val : linesBuffer) {
        swapByteOrder(val);
    }

    // Write
    fwrite(linesBuffer.data(), sizeof(int), linesBuffer.size(), file);
}

void VTKBinaryWriter::writeFinalHeaders() {
    char buffer[256];

    // Write LINES header (placeholder first to reserve space)
    fseek(file, 0, SEEK_END); // Go to end before writing LINES
    posLinesHeader = ftell(file);
    sprintf(buffer, "LINES %20lu %20lu\n", (unsigned long)0, (unsigned long)0); // Padded
    fwrite(buffer, sizeof(char), strlen(buffer), file);
    // long posAfterLinesHeader = ftell(file);

    // Write actual lines data
    writeLinesData();
    long posEnd = ftell(file);

    // Now seek back and write correct headers
    fseek(file, posPointsHeader, SEEK_SET);
    sprintf(buffer, "POINTS %20lu float\n", (unsigned long)totalPointCount);
    fwrite(buffer, sizeof(char), strlen(buffer), file);

    fseek(file, posLinesHeader, SEEK_SET);
    sprintf(buffer, "LINES %20lu %20lu\n", (unsigned long)totalStreamlineCount, (unsigned long)(totalStreamlineCount + totalPointCount));
    fwrite(buffer, sizeof(char), strlen(buffer), file);
    
    // Ensure we are at the end, might need ftruncate if padding made file too long
    // but with sprintf + fwrite, it should just overwrite. We seek to end to be sure.
    fseek(file, posEnd, SEEK_SET);

}


bool VTKBinaryWriter::close() {
    if (file == NULL) return false;

    writeFinalHeaders();
    fclose(file);
    file = nullptr;
    return true;
}