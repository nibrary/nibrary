#include <cstring>          // For std::strlen, std::memcpy
#include <numeric>          // For std::accumulate
#include <iomanip>          // For std::fixed, std::setprecision for float output
#include "base/nibr.h"      // For disp, SGNTR
#include "tractogramWriter_vtk_ascii.h"

namespace NIBR {

// Helper to append content of a source ASCII file to a destination ASCII file
bool VTKAsciiWriter::appendAsciiFileContent(FILE* dest, const std::string& srcFilename) 
{

    FILE* src = fopen(srcFilename.c_str(), "r"); // Read ASCII
    if (!src) {
        disp(MSG_ERROR, "VTKAsciiWriter: Failed to open temporary source file %s for appending.", srcFilename.c_str());
        return false;
    }

    char buffer[8192];
    bool success = true;

    while (fgets(buffer, sizeof(buffer), src) != nullptr) { // Read line by line
        if (fputs(buffer, dest) == EOF) {
            disp(MSG_ERROR, "VTKAsciiWriter: Failed to write to destination file while appending %s.", srcFilename.c_str());
            success = false;
            break;
        }
    }

    if (ferror(src)) {
        disp(MSG_ERROR, "VTKAsciiWriter: Error reading from temporary source file %s.", srcFilename.c_str());
        success = false;
    }

    fclose(src);
    return success;
}


VTKAsciiWriter::VTKAsciiWriter(std::string _filename) 
    : filename_(std::move(_filename)), 
      fieldsSet_(false)
{}

VTKAsciiWriter::~VTKAsciiWriter() 
{
    if (mainFile_ != nullptr) {
        disp(MSG_WARN, "VTKAsciiWriter for %s destroyed without explicit close. Attempting to close and clean up.", filename_.c_str());
        long dummy1, dummy2;
        close(dummy1, dummy2);
    } else {
        closeTemporaryFiles(true);
    }
}

void VTKAsciiWriter::setVTKFields(const std::vector<TractogramField>& fields) 
{
    fields_ = fields;
    fieldsSet_ = true;
}

bool VTKAsciiWriter::openTemporaryFiles() 
{
    tempPointsFilename_ = filename_ + ".points_ascii.tmp";
    tempPointsFile_     = fopen(tempPointsFilename_.c_str(), "w");

    if (!tempPointsFile_) {
        disp(MSG_ERROR, "VTKAsciiWriter: Failed to open temporary points file: %s", tempPointsFilename_.c_str());
        return false;
    }

    tempLinesFilename_  = filename_ + ".lines_ascii.tmp";
    tempLinesFile_      = fopen(tempLinesFilename_.c_str(), "w");

    if (!tempLinesFile_) {
        disp(MSG_ERROR, "VTKAsciiWriter: Failed to open temporary lines file: %s", tempLinesFilename_.c_str());
        return false;
    }
    
    return true;
}

void VTKAsciiWriter::closeTemporaryFiles(bool deleteFiles) 
{
    if (tempPointsFile_) { fclose(tempPointsFile_); tempPointsFile_ = nullptr;} 
    if (tempLinesFile_)  { fclose(tempLinesFile_);  tempLinesFile_  = nullptr;}

    if (deleteFiles) {
        remove(tempPointsFilename_.c_str()); 
        remove(tempLinesFilename_.c_str());
    }
    
}


bool VTKAsciiWriter::open() 
{
    mainFile_ = fopen(filename_.c_str(), "w"); 
    if (mainFile_ == nullptr) {
        disp(MSG_ERROR, "VTKAsciiWriter: Cannot open output file: %s", filename_.c_str());
        return false;
    }
    
    fprintf(mainFile_, "# vtk DataFile Version 3.0\n");
    fprintf(mainFile_, "Generated by %s\n", SGNTR().c_str());
    fprintf(mainFile_, "ASCII\n");
    fprintf(mainFile_, "DATASET POLYDATA\n");

    if (!openTemporaryFiles()) {
        fclose(mainFile_); mainFile_ = nullptr;
        remove(filename_.c_str());
        return false;
    }
    currentTotalPointCount_ = 0;
    currentStreamlineCount_ = 0;
    globalPointIndexOffset_ = 0;
    streamlineLengths_.clear();
    return true;
}

bool VTKAsciiWriter::writeBatch(const StreamlineBatch& batch) 
{
    if (!tempPointsFile_ || !tempLinesFile_) {
        disp(MSG_ERROR, "VTKAsciiWriter: Temporary files not open for writing.");
        return false;
    }

    for (const auto& streamline : batch) {
        if (streamline.empty()) {
            continue;
        }
        int num_points_in_streamline = static_cast<int>(streamline.size());
        streamlineLengths_.push_back(num_points_in_streamline); // Store length for field data writing

        // Write points to tempPointsFile_
        for (const auto& point : streamline) {
            fprintf(tempPointsFile_, "%.7g %.7g %.7g\n", point[0], point[1], point[2]);
        }
        
        // Write line connectivity to tempLinesFile_
        fprintf(tempLinesFile_, "%d", num_points_in_streamline);
        for (int i = 0; i < num_points_in_streamline; ++i) {
            fprintf(tempLinesFile_, " %ld", (long)(globalPointIndexOffset_ + i));
        }
        fprintf(tempLinesFile_, "\n");
        
        globalPointIndexOffset_ += num_points_in_streamline;
        currentStreamlineCount_++;
    }
    currentTotalPointCount_ = globalPointIndexOffset_;

    // Field data writing to temporary files would happen here if implemented.
    // For now, field data is assumed to be fully in memory and written in close().

    return true;
}

bool VTKAsciiWriter::close(long& finalStreamlineCount, long& finalPointCount) 
{
    if (mainFile_ == nullptr) {
        finalStreamlineCount = currentStreamlineCount_;
        finalPointCount      = currentTotalPointCount_;
        return true;
    }

    closeTemporaryFiles(false); // Close temp files, don't delete yet

    // Write final counts and append temp file contents to mainFile_
    fprintf(mainFile_, "POINTS %lu float\n", (unsigned long)currentTotalPointCount_);
    if (!appendAsciiFileContent(mainFile_, tempPointsFilename_)) {
        disp(MSG_ERROR, "VTKAsciiWriter: Failed to append temporary points data.");
        fclose(mainFile_); mainFile_ = nullptr; remove(filename_.c_str());
        closeTemporaryFiles(true);
        return false;
    }

    size_t total_connectivity_values = currentStreamlineCount_ + currentTotalPointCount_;
    fprintf(mainFile_, "LINES %lu %lu\n", (unsigned long)currentStreamlineCount_, (unsigned long)total_connectivity_values);
    if (!appendAsciiFileContent(mainFile_, tempLinesFilename_)) {
        disp(MSG_ERROR, "VTKAsciiWriter: Failed to append temporary lines data.");
        fclose(mainFile_); mainFile_ = nullptr; remove(filename_.c_str());
        closeTemporaryFiles(true);
        return false;
    }

    // --- Write Field Data (still assumes fields_ holds all data) ---
    if (fieldsSet_ && !fields_.empty()) {
        std::vector<const TractogramField*> point_fields;
        std::vector<const TractogramField*> cell_fields;
        for (const auto& field : fields_) {
            if (field.owner == POINT_OWNER) point_fields.push_back(&field);
            else if (field.owner == STREAMLINE_OWNER) cell_fields.push_back(&field);
        }

        if (!cell_fields.empty() && currentStreamlineCount_ > 0) {
            fprintf(mainFile_, "CELL_DATA %lu\n", (unsigned long)currentStreamlineCount_);
            for (const auto* field_ptr : cell_fields) {
                const TractogramField& field = *field_ptr;
                const char* typeStr = (field.datatype == FLOAT32_DT) ? "float" : ((field.datatype == INT32_DT) ? "int" : "unknown");
                fprintf(mainFile_, "SCALARS %s %s %d\n", field.name.c_str(), typeStr, field.dimension);
                fprintf(mainFile_, "LOOKUP_TABLE default\n");
                if (field.datatype == FLOAT32_DT) {
                    float** data_ptr = reinterpret_cast<float**>(field.data);
                    for (size_t i = 0; i < currentStreamlineCount_; ++i) {
                        if (data_ptr && data_ptr[i]) {
                            for (int d = 0; d < field.dimension; ++d) {
                                fprintf(mainFile_, "%.7g%s", data_ptr[i][d], (d == field.dimension - 1) ? "" : " ");
                            }
                            fprintf(mainFile_, "\n");
                        }
                    }
                } else if (field.datatype == INT32_DT) { /* similar for int */ }
            }
        }

        if (!point_fields.empty() && currentTotalPointCount_ > 0) {
            fprintf(mainFile_, "POINT_DATA %lu\n", (unsigned long)currentTotalPointCount_);
            for (const auto* field_ptr : point_fields) {
                const TractogramField& field = *field_ptr;
                const char* typeStr = (field.datatype == FLOAT32_DT) ? "float" : ((field.datatype == INT32_DT) ? "int" : "unknown");
                fprintf(mainFile_, "SCALARS %s %s %d\n", field.name.c_str(), typeStr, field.dimension);
                fprintf(mainFile_, "LOOKUP_TABLE default\n");
                
                size_t s_idx = 0;
                if (field.datatype == FLOAT32_DT) {
                    float*** data_ptr = reinterpret_cast<float***>(field.data);
                    for(int len : streamlineLengths_) {
                         if (data_ptr && data_ptr[s_idx]) {
                            for (int p = 0; p < len; ++p) {
                                if (data_ptr[s_idx][p]) {
                                    for (int d = 0; d < field.dimension; ++d) {
                                        fprintf(mainFile_, "%.7g%s", data_ptr[s_idx][p][d], (d == field.dimension - 1) ? "" : " ");
                                    }
                                    fprintf(mainFile_, "\n");
                                }
                            }
                        }
                        s_idx++;
                    }
                } else if (field.datatype == INT32_DT) { /* similar for int */ }
            }
        }
    }

    finalStreamlineCount = currentStreamlineCount_;
    finalPointCount      = currentTotalPointCount_;

    if (fclose(mainFile_) != 0) {
        disp(MSG_ERROR, "VTKAsciiWriter: Error closing main file %s.", filename_.c_str());
        mainFile_ = nullptr;
        closeTemporaryFiles(true);
        return false;
    }
    mainFile_ = nullptr;
    closeTemporaryFiles(true);

    disp(MSG_DEBUG, "VTKAsciiWriter: Successfully closed %s. Streamlines: %ld, Points: %ld", filename_.c_str(), finalStreamlineCount, finalPointCount);
    return true;
}

}
