#include <cstring>              // For std::strlen, std::memcpy
#include <numeric>              // For std::accumulate
#include "base/nibr.h"          // For disp, SGNTR
#include "base/byteSwapper.h"   // For swapByteOrder, is_little_endian
#include "tractogramWriter_vtk_binary.h"

namespace NIBR {

bool VTKBinaryWriter::appendFileContent(FILE* dest, const std::string& srcFilename) 
{
    FILE* src = fopen(srcFilename.c_str(), "rb");
    if (!src) {
        disp(MSG_ERROR, "VTKBinaryWriter: Failed to open temporary source file %s for appending.", srcFilename.c_str());
        return false;
    }

    char buffer[8192];
    size_t bytesRead;
    bool success = true;

    while ((bytesRead = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        if (fwrite(buffer, 1, bytesRead, dest) != bytesRead) {
            disp(MSG_ERROR, "VTKBinaryWriter: Failed to write to destination file while appending %s.", srcFilename.c_str());
            success = false;
            break;
        }
    }

    if (ferror(src)) {
        disp(MSG_ERROR, "VTKBinaryWriter: Error reading from temporary source file %s.", srcFilename.c_str());
        success = false;
    }

    fclose(src);
    return success;
}


VTKBinaryWriter::VTKBinaryWriter(std::string _filename) 
    : filename_(std::move(_filename)), 
      fieldsSet_(false)
{
    needsByteSwap_ = is_little_endian(); 
}

VTKBinaryWriter::~VTKBinaryWriter() 
{
    if (mainFile_ != nullptr) {
        disp(MSG_WARN, "VTKBinaryWriter for %s destroyed without explicit close. Attempting to close and clean up.", filename_.c_str());
        long dummy1, dummy2;
        close(dummy1, dummy2); // This will also try to delete temp files
    } else {
        closeTemporaryFiles();
    }
}

void VTKBinaryWriter::setVTKFields(const std::vector<TractogramField>& fields) 
{
    fields_     = fields;
    fieldsSet_  = true;
}

bool VTKBinaryWriter::openTemporaryFiles() 
{
    tempPointsFilename_ = filename_ + ".points.tmp";
    tempPointsFile_     = fopen(tempPointsFilename_.c_str(), "wb");
    if (!tempPointsFile_) {
        disp(MSG_ERROR, "VTKBinaryWriter: Failed to open temporary points file: %s", tempPointsFilename_.c_str());
        return false;
    }

    tempLinesFilename_  = filename_ + ".lines.tmp";
    tempLinesFile_      = fopen(tempLinesFilename_.c_str(), "wb");
    if (!tempLinesFile_) {
        disp(MSG_ERROR, "VTKBinaryWriter: Failed to open temporary lines file: %s", tempLinesFilename_.c_str());
        return false;
    }

    if (fieldsSet_) {
        tempFieldFiles_.clear();
        for (size_t i = 0; i < fields_.size(); ++i) {
            TempFieldInfo tfi;
            tfi.filename = filename_ + ".field_" + fields_[i].name + ".tmp";
            tfi.file_ptr = fopen(tfi.filename.c_str(), "wb");
            if (!tfi.file_ptr) {
                disp(MSG_ERROR, "VTKBinaryWriter: Failed to open temporary file for field %s: %s", fields_[i].name.c_str(), tfi.filename.c_str());
                closeTemporaryFiles();
                return false;
            }
            tempFieldFiles_.push_back(tfi);
        }
    }
    return true;
}

void VTKBinaryWriter::closeTemporaryFiles() 
{
    if (tempPointsFile_) { fclose(tempPointsFile_); tempPointsFile_ = nullptr;}
    if (tempLinesFile_)  { fclose(tempLinesFile_);  tempLinesFile_  = nullptr;}

    remove(tempPointsFilename_.c_str());
    remove(tempLinesFilename_.c_str());

    for (auto& tfi : tempFieldFiles_) {
        if (tfi.file_ptr) { fclose(tfi.file_ptr); tfi.file_ptr = nullptr;}
        remove(tfi.filename.c_str());
    }
    tempFieldFiles_.clear();
}

bool VTKBinaryWriter::open() 
{
    mainFile_ = fopen(filename_.c_str(), "wb"); 

    if (mainFile_ == nullptr) {
        disp(MSG_ERROR, "VTKBinaryWriter: Cannot open output file: %s", filename_.c_str());
        return false;
    }
    
    char buffer[256];

    sprintf(buffer, "# vtk DataFile Version 3.0\n");
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
    sprintf(buffer, "Generated by %s \n", SGNTR().c_str());
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
    sprintf(buffer, "BINARY\n"); 
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
    sprintf(buffer, "DATASET POLYDATA\n");
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_); 

    if (!openTemporaryFiles()) { 
        fclose(mainFile_); mainFile_ = nullptr;
        remove(filename_.c_str()); 
        return false;
    }

    currentTotalPointCount_ = 0;
    currentStreamlineCount_ = 0;
    globalPointIndexOffset_ = 0;
    streamlineLengths_.clear(); // Initialize streamlineLengths_
    return true;
}

bool VTKBinaryWriter::writeBatch(const StreamlineBatch& batch) 
{
    if (!tempPointsFile_ || !tempLinesFile_) { 
        disp(MSG_ERROR, "VTKBinaryWriter: Temporary files not open for writing.");
        return false;
    }

    std::vector<float>      batchPointsBuffer;
    std::vector<int32_t>    batchLinesBuffer;

    for (const auto& streamline : batch) {
        if (streamline.empty()) {
            continue;
        }
        int num_points_in_streamline = static_cast<int>(streamline.size());
        streamlineLengths_.push_back(num_points_in_streamline); // Populate streamlineLengths_
        
        for (const auto& point : streamline) {
            batchPointsBuffer.push_back(point[0]);
            batchPointsBuffer.push_back(point[1]);
            batchPointsBuffer.push_back(point[2]);
        }
        
        batchLinesBuffer.push_back(static_cast<int32_t>(num_points_in_streamline));
        for (int i = 0; i < num_points_in_streamline; ++i) {
            batchLinesBuffer.push_back(static_cast<int32_t>(globalPointIndexOffset_ + i));
        }
        
        globalPointIndexOffset_ += num_points_in_streamline;
        currentStreamlineCount_++;
    }
    currentTotalPointCount_ = globalPointIndexOffset_; 

    if (!batchPointsBuffer.empty()) {
        if (needsByteSwap_) {
            for (float& val : batchPointsBuffer) swapByteOrder(val);
        }
        if (fwrite(batchPointsBuffer.data(), sizeof(float), batchPointsBuffer.size(), tempPointsFile_) != batchPointsBuffer.size()) {
            disp(MSG_ERROR, "VTKBinaryWriter: Error writing points to temporary file %s.", tempPointsFilename_.c_str());
            return false;
        }
    }

    if (!batchLinesBuffer.empty()) {
        if (needsByteSwap_) {
            for (int32_t& val : batchLinesBuffer) swapByteOrder(val);
        }
        if (fwrite(batchLinesBuffer.data(), sizeof(int32_t), batchLinesBuffer.size(), tempLinesFile_) != batchLinesBuffer.size()) {
            disp(MSG_ERROR, "VTKBinaryWriter: Error writing lines to temporary file %s.", tempLinesFilename_.c_str());
            return false;
        }
    }
    
    // Field data batch writing to temp files is still omitted for brevity here,
    // focusing on fixing the streamlineLengths_ issue.
    // The close() method's field writing logic assumes fields_ has full data.

    return true;
}


bool VTKBinaryWriter::close(long& finalStreamlineCount, long& finalPointCount) 
{

    if (mainFile_ == nullptr) { 
        finalStreamlineCount = currentStreamlineCount_;
        finalPointCount      = currentTotalPointCount_;
        return true;
    }

    // Close files
    if (tempPointsFile_) { fclose(tempPointsFile_); tempPointsFile_ = nullptr;}
    if (tempLinesFile_)  { fclose(tempLinesFile_);  tempLinesFile_  = nullptr;}
    for (auto& tfi : tempFieldFiles_) {
        if (tfi.file_ptr) { fclose(tfi.file_ptr); tfi.file_ptr = nullptr;}
    } 

    // Append final data

    char buffer[256];

    sprintf(buffer, "POINTS %lu float\n", (unsigned long)currentTotalPointCount_);
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
    if (!appendFileContent(mainFile_, tempPointsFilename_)) {
        disp(MSG_ERROR, "VTKBinaryWriter: Failed to append temporary points data to main file.");
        fclose(mainFile_); mainFile_ = nullptr; remove(filename_.c_str()); 
        closeTemporaryFiles(); 
        return false;
    }
    fwrite("\n", sizeof(char), 1, mainFile_); 

    size_t total_connectivity_values = currentStreamlineCount_ + currentTotalPointCount_;
    sprintf(buffer, "LINES %lu %lu\n", (unsigned long)currentStreamlineCount_, (unsigned long)total_connectivity_values);
    fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
    if (!appendFileContent(mainFile_, tempLinesFilename_)) {
        disp(MSG_ERROR, "VTKBinaryWriter: Failed to append temporary lines data to main file.");
        fclose(mainFile_); mainFile_ = nullptr; remove(filename_.c_str());
        closeTemporaryFiles();
        return false;
    }
    fwrite("\n", sizeof(char), 1, mainFile_);

    if (fieldsSet_ && !fields_.empty()) {

        std::vector<const TractogramField*> point_fields;
        std::vector<const TractogramField*> cell_fields; 
        
        for (const auto& field : fields_) { 
            if (field.owner == POINT_OWNER) point_fields.push_back(&field);
            else if (field.owner == STREAMLINE_OWNER) cell_fields.push_back(&field);
        }

        if (!cell_fields.empty() && currentStreamlineCount_ > 0) {
            sprintf(buffer, "CELL_DATA %lu\n", (unsigned long)currentStreamlineCount_);
            fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
            for (const auto* field_ptr : cell_fields) {
                const TractogramField& field = *field_ptr;
                const char* typeStr = (field.datatype == FLOAT32_DT) ? "float" : ((field.datatype == INT32_DT) ? "int" : "unknown");
                sprintf(buffer, "SCALARS %s %s %d\n", field.name.c_str(), typeStr, field.dimension);
                fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
                sprintf(buffer, "LOOKUP_TABLE default\n");
                fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);

                if (field.datatype == FLOAT32_DT) {
                    float** data_ptr = reinterpret_cast<float**>(field.data);
                    for (size_t i = 0; i < currentStreamlineCount_; ++i) {
                        if (data_ptr && data_ptr[i]) {
                            std::vector<float> temp_data(field.dimension);
                            std::memcpy(temp_data.data(), data_ptr[i], field.dimension * sizeof(float));
                            if (needsByteSwap_) for(float& val : temp_data) swapByteOrder(val);
                            fwrite(temp_data.data(), sizeof(float), field.dimension, mainFile_);
                        } 
                    }
                } else if (field.datatype == INT32_DT) { 
                    int** data_ptr = reinterpret_cast<int**>(field.data);
                    for (size_t i = 0; i < currentStreamlineCount_; ++i) {
                        if (data_ptr && data_ptr[i]) {
                            std::vector<int32_t> temp_data(field.dimension);
                            std::memcpy(temp_data.data(), data_ptr[i], field.dimension * sizeof(int32_t));
                            if (needsByteSwap_) for(int32_t& val : temp_data) swapByteOrder(val);
                            fwrite(temp_data.data(), sizeof(int32_t), field.dimension, mainFile_);
                        }
                    }
                }
                fwrite("\n", sizeof(char), 1, mainFile_);
            }
        }

        if (!point_fields.empty() && currentTotalPointCount_ > 0) {
            sprintf(buffer, "POINT_DATA %lu\n", (unsigned long)currentTotalPointCount_);
            fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
             for (const auto* field_ptr : point_fields) {
                const TractogramField& field = *field_ptr;
                const char* typeStr = (field.datatype == FLOAT32_DT) ? "float" : ((field.datatype == INT32_DT) ? "int" : "unknown");
                sprintf(buffer, "SCALARS %s %s %d\n", field.name.c_str(), typeStr, field.dimension);
                fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
                sprintf(buffer, "LOOKUP_TABLE default\n");
                fwrite(buffer, sizeof(char), std::strlen(buffer), mainFile_);
                
                if (field.datatype == FLOAT32_DT) {
                    float*** data_ptr = reinterpret_cast<float***>(field.data);
                    size_t s_idx = 0;
                    for(int len : streamlineLengths_) { // Iterate using stored streamlineLengths_
                        if (data_ptr && data_ptr[s_idx]) {
                            for (int p = 0; p < len; ++p) {
                                if (data_ptr[s_idx][p]) {
                                    std::vector<float> temp_data(field.dimension);
                                    std::memcpy(temp_data.data(), data_ptr[s_idx][p], field.dimension * sizeof(float));
                                    if (needsByteSwap_) for(float& val : temp_data) swapByteOrder(val);
                                    fwrite(temp_data.data(), sizeof(float), field.dimension, mainFile_);
                                }
                            }
                        }
                        s_idx++;
                    }
                } else if (field.datatype == INT32_DT) { 
                    int*** data_ptr = reinterpret_cast<int***>(field.data);
                    size_t s_idx = 0;
                    for(int len : streamlineLengths_) { 
                        if (data_ptr && data_ptr[s_idx]) {
                            for (int p = 0; p < len; ++p) {
                                if (data_ptr[s_idx][p]) {
                                    std::vector<int32_t> temp_data(field.dimension);
                                    std::memcpy(temp_data.data(), data_ptr[s_idx][p], field.dimension * sizeof(int32_t));
                                    if (needsByteSwap_) for(int32_t& val : temp_data) swapByteOrder(val);
                                    fwrite(temp_data.data(), sizeof(int32_t), field.dimension, mainFile_);
                                }
                            }
                        }
                        s_idx++;
                    }
                }
                fwrite("\n", sizeof(char), 1, mainFile_);
            }
        }
    }


    finalStreamlineCount = currentStreamlineCount_;
    finalPointCount      = currentTotalPointCount_;

    if (fclose(mainFile_) != 0) {
        disp(MSG_ERROR, "VTKBinaryWriter: Error closing main file %s.", filename_.c_str());
        mainFile_ = nullptr;
        closeTemporaryFiles(); 
        return false;
    }
    mainFile_ = nullptr;
    
    closeTemporaryFiles(); 

    disp(MSG_DEBUG, "VTKBinaryWriter: Successfully closed %s. Streamlines: %ld, Points: %ld", filename_.c_str(), finalStreamlineCount, finalPointCount);
    return true;
}

}
