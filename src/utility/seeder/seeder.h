#pragma once

#include "image/image.h"
#include "surface/surface.h"

namespace NIBR
{

typedef enum
{
    SEED_OK,
    SEED_REACHED_MAX_COUNT,
    SEED_ERROR
} SeederOutputState;

typedef enum {
	SEED_NOTSET = -1,
	SEED_IMAGE_MASK,
    SEED_IMAGE_RS,                      // Rejection sampling
    SEED_SHPERE,
    SEED_LIST,
    SEED_LIST_WITH_DIRECTIONS,
    SEED_SURFACE_MASK,
    SEED_SURFACE_RS,                    // Rejection sampling
    SEED_SURFACE_MASK_WITH_DIRECTIONS,
    SEED_SURFACE_RS_WITH_DIRECTIONS,
    SEED_INSIDE_SURFACE,
} SeedingMode;


class Seeder {

public:

    Seeder() {};
    virtual ~Seeder() {}

    virtual SeederOutputState getSeed(float* p, int threadNo) = 0;
    virtual SeederOutputState getSeed(float* p, float* dir, int threadNo) = 0;

    SeederOutputState getSeed(float* p) {return getSeed(p,0);}
    SeederOutputState getSeed(float* p, float* dir) {return getSeed(p,dir,0);}

    virtual void computeSeedCountAndDensity()  = 0;
	virtual void computeMaxPossibleSeedCount() = 0;
    virtual void setNumberOfThreads(int n) = 0;
    int getNumberOfThreads() {return threadCount;}

    // Image
    virtual bool setSeed(Image<int8_t>* img) = 0;
    virtual bool setSeed(Image<int>*,   int) = 0;
    virtual bool setSeed(Image<float>*  img) = 0;
    virtual bool setSeed(Image<float>*  img, int volInd) = 0;

    // Sphere
    virtual bool setSeed(float x, float y, float z, float r) = 0;
	virtual bool setSeed(Point xyz, float r) = 0;
	virtual bool setSeed(float* p,  float r) = 0;

    // List
    virtual bool setSeed(std::vector<Point>& p) = 0;
	virtual bool setSeed(std::vector<Point>& p, std::vector<Point>& dir) = 0;

    // Surface
    virtual bool setSeed(Surface *surf) = 0;
    virtual bool setSeed(Surface *surf, float discRes) = 0;

    // Surface options
    virtual bool useDensity   (std::vector<float>& density) = 0; // per face seeding density values
    virtual void useSurfNorm  (bool use) = 0;


    SeederOutputState checkSeedingLimits() {
        if (curSeed>=maxPossibleSeedCount) return SEED_REACHED_MAX_COUNT;
        return SEED_OK;
    }

    void  setDensity(float _density) {density = (_density<0) ? 0 : _density; hasDensity = true; }
    void  setCount  (long _count)    {count   = (_count<0)   ? 0 : _count;   hasDensity = false;}
    void  reset() {curSeed = 0;}

    SeedingMode mode{SEED_NOTSET};
    float       density{0};             // #/mm3 for images, #/mm2 for surface meshes
    long        count{0};               // Maximum number of seeds that can be generated by the seeder
    bool        hasDensity{false};
    long        curSeed;
    long        maxPossibleSeedCount;
    int         threadCount{1};

};
}